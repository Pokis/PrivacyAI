/**
 * marked - a markdown parser
 * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? t(exports) : "function" == typeof define && define.amd ? define(["exports"], t) : t((e = "undefined" != typeof globalThis ? globalThis : e || self).marked = {}) }(this, (function (e) { "use strict"; function t(e) { return { async: !!(e || {}).async, break: !!(e || {}).break, extensions: (e || {}).extensions || null, gfm: !!(e || {}).gfm, hooks: (e || {}).hooks || null, pedantic: !!(e || {}).pedantic, renderer: (e || {}).renderer || null, silent: !!(e || {}).silent, tokenizer: (e || {}).tokenizer || null, walkTokens: (e || {}).walkTokens || null } } function n(e) { e.extensions = { childTokens: {}, inline: [] }, e.walkTokens = function (t) { let n; for (const s of t) switch (n = e.extensions.childTokens[s.type], n && e.walkTokens(n.map((e => s[e])).flat(1 / 0)), s.items && e.walkTokens(s.items), s.tokens && e.walkTokens(s.tokens), s.type) { case "list": e.walkTokens(s.items); break; case "table": for (const t of s.rows) for (const n of t) e.walkTokens(n.tokens); e.walkTokens(s.header.flat()); break; case "blockquote": e.walkTokens(s.tokens); break; case "html": case "tag": case "code": case "codespan": case "def": case "escape": case "hr": case "image": case "link": case "space": case "text": break; default: e.extensions.inline.some((t => !!t(s, e.walkTokens))) } } } class s { constructor(e) { this.options = e || {} } space(e) { const t = this.rules.block.newline.exec(e); if (t) return t[0].length > 0 ? { type: "space", raw: t[0] } : void 0 } code(e) { const t = this.rules.block.code.exec(e); if (t) { const e = t[0].replace(/^ {1,4}/gm, ""); return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? e : e.replace(/\n+$/, "") } } } fences(e) { const t = this.rules.block.fences.exec(e); if (t) { const e = t[0], n = function (e, t) { const n = e.match(/^(\s+)(?:```)/); if (null === n) return t; const s = n[1]; return t.split("\n").map((e => { const t = e.match(/^\s+/); if (null === t) return e; const [n] = t; return n.length >= s.length ? e.slice(s.length) : e })).join("\n") }(e, t[3] || ""); return { type: "code", raw: e, lang: t[2] ? t[2].trim().replace(this.rules.inline._escapes, "$1") : t[2], text: n } } } heading(e) { const t = this.rules.block.heading.exec(e); if (t) { let e = t[2].trim(); if (/#$/.test(e)) { const t = e.trimRight(); e = t.substring(0, t.length - 1).trim() } return { type: "heading", raw: t[0], depth: t[1].length, text: e, tokens: this.lexer.inline(e) } } } hr(e) { const t = this.rules.block.hr.exec(e); if (t) return { type: "hr", raw: t[0] } } blockquote(e) { const t = this.rules.block.blockquote.exec(e); if (t) { const e = t[0].replace(/^ *>[ \t]?/gm, ""), n = this.lexer.state.top; this.lexer.state.top = !0; const s = this.lexer.blockTokens(e); return this.lexer.state.top = n, { type: "blockquote", raw: t[0], tokens: s, text: e } } } list(e) { let t = this.rules.block.list.exec(e); if (t) { let e, n = t[1].trim(); const s = n.length > 1, r = { type: "list", raw: "", ordered: s, start: s ? +n.slice(0, -1) : "", loose: !1, items: [] }; n = s ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = s ? n : "[*+-]"); const i = new RegExp(`^( {0,3}${n})((?:[\t ][^\\n]*)?(?:\\n|$))`); for (; e && (this.rules.block.hr.test(e) || (this.rules.block.heading.test(e) || (this.rules.block.blockquote.test(e) || (this.rules.block.fences.test(e) || this.rules.block.html.test(e) || (this.rules.block.def.test(e) || this.rules.block.table.test(e) || this.rules.block.lheading.test(e)))))) || (e = t[0], t = this.rules.block.list.exec(e), !(!t || this.rules.block.hr.test(e) || (this.rules.block.heading.test(e) || (this.rules.block.blockquote.test(e) || (this.rules.block.fences.test(e) || this.rules.block.html.test(e) || (this.rules.block.def.test(e) || this.rules.block.table.test(e) || this.rules.block.lheading.test(e))))))));){ let e=t[2], n=t[0].indexOf("\n") + 1, s=t[0].length, o=n < s && t[0].trimRight().endsWith("\n"); if(this.options.pedantic){ const t = e.indexOf("\n"); -1 !== t && (e = e.slice(0, t), s = n + t) } const l = new RegExp(`^ {0,3}${n}((?:[\t ][^\\n]*)?(?:\\n|$))`), a = new RegExp(`^ {0,3}${n}((?:[^\\n]*)?(?:\\n|$))`); for (; n < s && (o || ((e = t[0].slice(n)).length > 0 && (this.rules.block.hr.test(e) || (this.rules.block.heading.test(e) || (this.rules.block.blockquote.test(e) || (this.rules.block.fences.test(e) || this.rules.block.html.test(e) || (this.rules.block.def.test(e) || this.rules.block.table.test(e) || this.rules.block.lheading.test(e)))))))));) { const e = l.exec(t[0].slice(n)), s = a.exec(t[0].slice(n)); if (e && (s && (s[1].length >= e[1].length || (n += e[0].length, r.items.push({ type: "list_item", raw: e[0], task: !1, checked: void 0, loose: !1, text: e[1].trim(), tokens: this.lexer.inline(e[1].trim()) }), t = this.rules.block.list.exec(t[0].slice(n)))), !e)) break; if (r.items.length > 0 && (r.items[r.items.length - 1].loose = !0, r.loose = !0), n += e[0].length, r.items.push({ type: "list_item", raw: e[0], task: !1, checked: void 0, loose: !1, text: e[1].trim(), tokens: this.lexer.inline(e[1].trim()) }), t = this.rules.block.list.exec(t[0].slice(n))} r.raw += t[0]}return r}}html(e){ const t = this.rules.block.html.exec(e); if (t) { const e = { type: "html", raw: t[0], pre: !this.options.sanitizer && (t[1] || t[2] || t[3]), text: t[0] }; return this.options.sanitize && (e.type = "paragraph", e.text = this.options.sanitizer ? this.options.sanitizer(t[0]) : l(t[0]), e.tokens = this.lexer.inline(e.text)), e } } def(e){ const t = this.rules.block.def.exec(e); if (t) { const e = t[1].toLowerCase().replace(/\s+/g, " "), n = t[2] ? t[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : t[2], s = t[3] && t[3].substring(1, t[3].length - 1).replace(this.rules.inline._escapes, "$1"); return { type: "def", tag: e, raw: t[0], href: n, title: s } } } table(e){ const t = this.rules.block.table.exec(e); if (t) { const e = { type: "table", header: t[1].replace(/^ *| *\| *$/g, "").split(/ *\| */), align: t[2].replace(/^ *|\| *$/g, "").split(/ *\| */), rows: t[3] ? t[3].replace(/(?: *\| *)?\n$/, "").split("\n") : [] }; for (e.header.length === e.align.length ? e.raw = t[0] : e = void 0; e.align.length < e.header.length;)e.align.push(null); for (; e.align.length > e.header.length;)e.align.pop(); for (let t = 0; t < e.align.length; t++)/^ *-+: *$/.test(e.align[t]) ? e.align[t] = "right" : /^ *:-+: *$/.test(e.align[t]) ? e.align[t] = "center" : /^ *:-+ *$/.test(e.align[t]) ? e.align[t] = "left" : e.align[t] = null; for (let t = 0; t < e.rows.length; t++)e.rows[t] = e.rows[t].replace(/^ *\| *| *\| *$/g, "").split(/ *\| */); return e } } lheading(e){ const t = this.rules.block.lheading.exec(e); if (t) return { type: "heading", raw: t[0], depth: "=" === t[2].charAt(0) ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) } } paragraph(e){ const t = this.rules.block.paragraph.exec(e); if (t) return { type: "paragraph", raw: t[0], text: "\n" === t[1].charAt(t[1].length - 1) ? t[1].slice(0, -1) : t[1], tokens: this.lexer.inline(t[1].replace(/\n$/, "")) } } text(e){ const t = this.rules.block.text.exec(e); if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) } } escape(e){ const t = this.rules.inline.escape.exec(e); if (t) return { type: "escape", raw: t[0], text: l(t[1]) } } tag(e){ const t = this.rules.inline.tag.exec(e); if (t) { const e = { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, text: t[0] }; return this.options.sanitize && (e.type = "text", e.text = l(t[0]), e.tokens = this.lexer.inline(e.text)), e } } link(e){ const t = this.rules.inline.link.exec(e); if (t) { const e = t[2].trim(); if (!this.options.pedantic && /^</.test(e)) { if (!/>$/.test(e)) return; const t = e.slice(1, -1); if (t.length - t.replace(/([^\\])\\([^\\])/g, "$1$2").length != 0) return; const n = t.indexOf(t.replace(/([^\\])\\([^\\])/g, "$1$2")); if (n !== -1 && n !== 0) return } const n = t[2].trim().replace(/^<([\s\S]*)>$/, "$1").replace(this.rules.inline._escapes, "$1"), s = t[0].length, r = t[1].length + 2 + n.length; if (s > r + 1) return; const i = t[0].charAt(0); if ("!" !== i && 0 !== s - r) { if (")" !== t[0].charAt(s - 1)) return; const e = t[0].lastIndexOf(")"); if (e === s - 1) { const e = t[0].lastIndexOf("(", s - 2); if (e !== -1 && t[0].charAt(e - 1) === "]") return { type: "link", raw: t[0], href: n, tokens: this.lexer.inline(t[1]), text: t[1] } } } const o = this.rules.inline.href.exec(t[0]); if (o) return { type: "link", raw: o[0], href: o[2], title: o[3] ? o[3].slice(1, -1) : null, tokens: this.lexer.inline(o[1]), text: o[1] } } } reflink(e, t){ let n; if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) { let e = (n[2] || n[1]).replace(/\s+/g, " "); if (e = t[e.toLowerCase()], !e || !e.href) { const e = n[0].charAt(0); return { type: "text", raw: e, text: e } } return { type: "link", raw: n[0], href: e.href, title: e.title, tokens: this.lexer.inline(n[1]), text: n[1] } } } strong(e){ const t = this.rules.inline.strong.exec(e); if (t) return { type: "strong", raw: t[0], text: t[4] || t[3] || t[2] || t[1], tokens: this.lexer.inline(t[4] || t[3] || t[2] || t[1]) } } em(e){ const t = this.rules.inline.em.exec(e); if (t) return { type: "em", raw: t[0], text: t[6] || t[5] || t[4] || t[3] || t[2] || t[1], tokens: this.lexer.inline(t[6] || t[5] || t[4] || t[3] || t[2] || t[1]) } } codespan(e){ const t = this.rules.inline.code.exec(e); if (t) { let e = t[2].replace(/\n/g, " "); const n = /[^ ]/.test(e), s = /^ /.test(e) && / $/.test(e); return n && s && (e = e.substring(1, e.length - 1)), e = l(e, !0), { type: "codespan", raw: t[0], text: e } } } br(e){ const t = this.rules.inline.br.exec(e); if (t) return { type: "br", raw: t[0] } } del(e){ const t = this.rules.inline.del.exec(e); if (t) return { type: "del", raw: t[0], text: t[1], tokens: this.lexer.inline(t[1]) } } autolink(e, t){ const n = this.rules.inline.autolink.exec(e); if (n) { let e, s; return "@" === n[2] ? (e = l(n[1]), s = "mailto:" + e) : (e = l(n[1]), s = e), { type: "link", raw: n[0], text: e, href: s, tokens: [{ type: "text", raw: e, text: e }] } } } url(e, t){ let n; if (n = this.rules.inline.url.exec(e)) { let e, s; if ("@" === n[2]) e = l(n[0]), s = "mailto:" + e; else { let t; do { t = n[0], n[0] = this.rules.inline._backpedal.exec(n[0])[0] } while (t !== n[0]); e = l(n[0]), s = "www." === n[1] ? "http://" + e : e } return { type: "link", raw: n[0], text: e, href: s, tokens: [{ type: "text", raw: e, text: e }] } } } inlineText(e, t){ const n = this.rules.inline.text.exec(e); if (n) { let e; return e = this.lexer.state.inRawBlock ? this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(n[0]) : l(n[0]) : n[0] : l(n[0]), { type: "text", raw: n[0], text: e } } }}const r = { newline: /^(?: *(?:\n|$))+/, code: /^( {4}[^\n]+(?:\n(?:(?: {4}[^\n]+)|(?: {0,3}(?:\n|$)))+)?)+/, fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/, hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/, heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/, list: /^( {0,3})((?:[*+-]|\d{1,9}[.)]))( [\s\S]+?)(?:\n+(?=\1?(?:[-*_] *){3,}(?:\n+|$))|\n+(?= *\[((?:x|X| )?)\][ .])|\n+(?= {0,3}((?:[*+-]|\d{1,9}[.)]))( [\s\S]+?))|\n+(?=\1?(?:#{1,6}))|\n+(?=\1{0,3}>)|$)/, html: "^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?\\?>\\n+|<![A-Z][\\s\\S]*?>\\n+|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n+|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$))", def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/, table: c, lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, text: /^[^\n]+/, _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, _comment: /<!--(?!-?>)[\s\S]*?-->/, _label: /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/, _title: /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/, _tag: "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", _attribute: /\s+[a-zA-Z^_:][\w.:-]*(?:\s*=\s*(?:[^"'=<>`\s]+|"[^"]*"|'[^']*'))*/, block: {}, inline: {} }; r.block.newline = r.newline, r.block.code = r.code, r.block.fences = r.fences, r.block.hr = r.hr, r.block.heading = r.heading, r.block.blockquote = r.blockquote, r.block.list = r.list, r.block.html = r.html.replace("comment", r._comment).replace("tag", r._tag).replace("attribute", r._attribute), r.block.def = r.def.replace("label", r._label).replace("title", r._title), r.block.table = r.table, r.block.lheading = r.lheading, r.block.paragraph = r.paragraph, r.block.text = r.text, r.inline.escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, r.inline.tag = /^comment|^</ ? tag(?: attribute) * *\\/?>/, r.inline.tag = new RegExp(r.inline.tag.source.replace("comment", r._comment).replace("tag", r._tag).replace("attribute", r._attribute)), r.inline.link = /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/, r.inline.link = new RegExp(r.inline.link.source.replace("label", r._label).replace("href", /<(?:\\<|[^<>])*>|[^\s\x00-\x1f]*/).replace("title", r._title)), r.inline.reflink = /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]|[^\[\]])*)\]/, r.inline.reflink = new RegExp(r.inline.reflink.source.replace("label", r._label)), r.inline.nolink = /^!?\[(label)\](?:\[\])?/, r.inline.nolink = new RegExp(r.inline.nolink.source.replace("label", r._label)), r.inline.strong = /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)|^_([^\s_])_(?!_)|^\*([^\s*])\*(?!\*)|^_([^\s][\s\S]*?[^\s])_(?!_)|^\*([^\s][\s\S]*?[^\s])\*(?!\*)/, r.inline.em = /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)|^_([^\s_])_(?!_)|^\*([^\s*])\*(?!\*)|^_([^\s][\s\S]*?[^\s])_(?!_)|^\*([^\s][\s\S]*?[^\s])\*(?!\*)/, r.inline.code = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, r.inline.br = /^( {2,}|\\)\n(?!\s*$)/, r.inline.del = c, r.inline.autolink = /^<([^ >]+(@|:\/)[^ >]+)>/, r.inline.url = /^((?:ftp|https?):\/\/|www\.)[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)+(?:[\w.,@?^=%&amp;:\/~+#-]*[\w@?^=%&amp;\/~+#-])?/, r.inline._backpedal = /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)](?!$))+/, r.inline.text = /^[\s\S]+?(?=[\\<!\[`*]|\b_| {2,}\n|$)/; const i = { name: "gfm", tokenize(e, t) { return { type: "text", raw: e, text: e } } }; function o(e, t, n) { if (null == e) throw new Error("marked(): input parameter is undefined or null"); if ("string" != typeof e) throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"); if ("function" == typeof t && (n = t, t = null), t = Object.assign({}, s.defaults, t || {}), n) { const s = t.highlight; let i; try { i = a.lex(e, t) } catch (e) { return n(e) } const l = function (e) { let i; if (!e) try { t.walkTokens && s.walkTokens(i, t.walkTokens), i = a.parser(i, t) } catch (e) { return n(e) } return t.highlight ? n(null, i) : e ? n(null, e) : n(null, i) }; if (!s || s.length < 3) return l(); if (delete t.highlight, !i.length) return l(); let c = 0; s.walkTokens(i, (function (e) { "code" === e.type && (c++, setTimeout((() => { s.highlight(e.text, e.lang, (function (t, n) { if (t) return l(t); null != n && n !== e.text && (e.text = n, e.escaped = !0), c--, 0 === c && l() })) }), 0)) })), 0 === c && l() } try { const n = a.lex(e, t); return t.walkTokens && s.walkTokens(n, t.walkTokens), a.parser(n, t) } catch (e) { if (t.silent) return "<p>An error occurred:</p><pre>" + l(e.message + "", !0) + "</pre>"; throw e } } function l(e, t) { if (t) { if (p.test(e)) return e.replace(h, u) } else if (p.test(e)) return e.replace(d, u); return e } const a = { defaults: { async: !1, break: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null }, options: function (e) { return Object.assign(this.defaults, e), this }, getText: function (e) { return e.text }, lex: function (e, t) { return e = e.replace(/\r\n|\r/g, "\n"), n(t = t || a.defaults), new s(t).lex(e) }, parser: function (e, t) { return n(t = t || a.defaults), new r(t).parse(e) } }; class c { constructor(t) { this.tokens = [], this.tokens.links = Object.create(null), this.options = t || a.defaults, this.options.tokenizer = this.options.tokenizer || new e.Tokenizer(this.options), this.options.renderer = this.options.renderer || new e.Renderer(this.options), this.options.renderer.options = this.options, this.tokenizer = this.options.tokenizer, this.renderer = this.options.renderer } static lex(e, t) { return new c(t).lex(e) } lex(e) { let t; for (e = e.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    "), this.blockTokens(e, this.tokens); t = this.inlineQueue.shift();)this.inlineTokens(t.src, t.tokens); return this.tokens } blockTokens(e, t = []) { let n, s, r, i; for (this.options.pedantic && (e = e.replace(/\t/g, "    ").replace(/^ +$/gm, "")); e;)if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((s => !!(n = s.call({ lexer: this }, e, t)) && (e = e.substring(n.raw.length), t.push(n), !0))))) { if (n = this.tokenizer.space(e)) { e = e.substring(n.raw.length), 1 === n.raw.length && t.length > 0 ? t[t.length - 1].raw += "\n" : t.push(n); continue } if (n = this.tokenizer.code(e)) { e = e.substring(n.raw.length), s = t[t.length - 1], !s || "paragraph" !== s.type && "text" !== s.type ? t.push(n) : (s.raw += "\n" + n.raw, s.text += "\n" + n.text, this.inlineQueue[this.inlineQueue.length - 1].src = s.text); continue } if (n = this.tokenizer.fences(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.heading(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.hr(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.blockquote(e)) { e = e.substring(n.raw.length), n.tokens = this.blockTokens(n.text, []), t.push(n); continue } if (n = this.tokenizer.list(e)) { for (e = e.substring(n.raw.length), r = n.items.length, i = 0; i < r; i++)n.items[i].tokens = this.blockTokens(n.items[i].text, []); t.push(n); continue } if (n = this.tokenizer.html(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.def(e)) { e = e.substring(n.raw.length), s = t[t.length - 1], !s || "paragraph" !== s.type && "text" !== s.type ? this.tokens.links[n.tag] || (this.tokens.links[n.tag] = { href: n.href, title: n.title }) : (s.raw += "\n" + n.raw, s.text += "\n" + n.raw, this.inlineQueue[this.inlineQueue.length - 1].src = s.text); continue } if (n = this.tokenizer.table(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.lheading(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.paragraph(e)) { e = e.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.text(e)) { e = e.substring(n.raw.length), s = t[t.length - 1], s && "text" === s.type ? (s.raw += "\n" + n.raw, s.text += "\n" + n.text, this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : t.push(n); continue } if (e) { const t = "Infinite loop on byte: " + e.charCodeAt(0); if (this.options.silent) { console.error(t); break } throw new Error(t) } } return t } inline(e, t = []) { return this.inlineQueue = [], this.inlineTokens(e, t), this.inlineQueue.forEach((e => { this.inlineTokens(e.src, e.tokens) })), t } inlineTokens(e, t = []) { let n, s, r, i, o, l, a = e; if (this.tokens.links) { const e = Object.keys(this.tokens.links); if (e.length > 0) for (; null != (n = this.tokenizer.reflink(a, this.tokens.links));)a = a.substring(n.raw.length), t.push(n) } for (; null != (n = this.tokenizer.escape(a));)a = a.substring(n.raw.length), t.push(n); for (; a.length > 0;) { if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((e => !!(n = e.call({ lexer: this }, a, t)) && (a = a.substring(n.raw.length), t.push(n), !0)))); else { if (n = this.tokenizer.tag(a)) { a = a.substring(n.raw.length), s = t[t.length - 1], s && "text" === s.type ? (s.raw += n.raw, s.text += n.text, this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : t.push(n); continue } if (n = this.tokenizer.link(a)) { a = a.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.reflink(a, this.tokens.links)) { a = a.substring(n.raw.length), s = t[t.length - 1], s && "text" === s.type ? (s.raw += n.raw, s.text += n.text, this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : t.push(n); continue } if (n = this.tokenizer.strong(a)) { a = a.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.em(a)) { a = a.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.codespan(a)) { a = a.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.br(a)) { a = a.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.del(a)) { a = a.substring(n.raw.length), t.push(n); continue } if (n = this.tokenizer.autolink(a)) { a = a.substring(n.raw.length), t.push(n); continue } if (this.options.gfm) { if (n = this.tokenizer.url(a)) { a = a.substring(n.raw.length), t.push(n); continue } } if (r = a, this.options.extensions && this.options.extensions.startBlock) { let e = 1 / 0; const t = a.slice(1); let n; this.options.extensions.startBlock.forEach((s => { n = s.call({ lexer: this }, t), "number" == typeof n && n >= 0 && (e = Math.min(e, n)) })), e < 1 / 0 && e >= 0 && (r = a.substring(0, e + 1)) } if (this.tokenizer.rules.inline.url && (n = this.tokenizer.rules.inline.url.exec(r), n && (r = r.slice(0, n.index))), i = r.search(this.tokenizer.rules.inline._backpedal), i !== -1 && (l = r.slice(0, i), a = a.slice(i)), o = r, i !== -1 && (o = l), n = this.tokenizer.inlineText(o, l)) { a = a.substring(n.raw.length), "_" !== n.raw.slice(-1) && (s = t[t.length - 1]), s && "text" === s.type ? (s.raw += n.raw, s.text += n.text, this.inlineQueue[this.inlineQueue.length - 1].src = s.text) : t.push(n); continue } if (a) { const t = "Infinite loop on byte: " + a.charCodeAt(0); if (this.options.silent) { console.error(t); break } throw new Error(t) } } } return t } } const h = /[&<>"']/, p = new RegExp(h.source), u = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }; e.defaults = { async: !1, break: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null }, e.marked = o, e.options = a.options, e.parse = o, e.parser = a.parser, e.lexer = a.lex, e.Tokenizer = s, e.Renderer = class { constructor(e) { this.options = e || a.defaults } code(e, t, n) { const s = (t || "").match(/\S*/)[0]; if (this.options.highlight) { const t = this.options.highlight(e, s); null != t && t !== e && (n = !0, e = t) } return e = e.replace(/\n$/, "") + '\n', s ? '<pre><code class="' + this.options.langPrefix + l(s, !0) + '">' + (n ? e : l(e, !0)) + "</code></pre>\n" : '<pre><code>' + (n ? e : l(e, !0)) + "</code></pre>\n" } blockquote(e) { return "<blockquote>\n" + e + "</blockquote>\n" } html(e) { return e } heading(e, t, n, s) { return this.options.headerIds ? "<h" + t + ' id="' + this.options.headerPrefix + s.slug(n) + '">' + e + "</h" + t + ">\n" : "<h" + t + ">" + e + "</h" + t + ">\n" } hr() { return "<hr>\n" } list(e, t, n) { const s = t ? "ol" : "ul", r = t && 1 !== n ? ' start="' + n + '"' : ""; return "<" + s + r + ">\n" + e + "</" + s + ">\n" } listitem(e) { return "<li>" + e + "</li>\n" } checkbox(e) { return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox"> ' } paragraph(e) { return "<p>" + e + "</p>\n" } table(e, t) { return t && (t = "<tbody>" + t + "</tbody>"), "<table>\n<thead>\n" + e + "</thead>\n" + t + "</table>\n" } tablerow(e) { return "<tr>\n" + e + "</tr>\n" } tablecell(e, t) { const n = t.header ? "th" : "td"; return (t.align ? '<' + n + ' align="' + t.align + '">' : "<" + n + ">") + e + "</" + n + ">\n" } strong(e) { return "<strong>" + e + "</strong>" } em(e) { return "<em>" + e + "</em>" } codespan(e) { return "<code>" + e + "</code>" } br() { return "<br>" } del(e) { return "<del>" + e + "</del>" } link(e, t, n) { if (null === (e = function (e) { try { return encodeURI(e).replace(/%25/g, "%") } catch (t) { return null } }(e))) return n; let s = '<a href="' + l(e) + '"'; return t && (s += ' title="' + l(t) + '"'), s + ">" + n + "</a>" } image(e, t, n) { if (null === (e = function (e) { try { return encodeURI(e).replace(/%25/g, "%") } catch (t) { return null } }(e))) return n; let s = '<img src="' + l(e) + '" alt="' + n + '"'; return t && (s += ' title="' + l(t) + '"'), s + (this.options.xhtml ? "/>" : ">") } text(e) { return e } }, e.TextRenderer = class { strong(e) { return e } em(e) { return e } codespan(e) { return e } del(e) { return e } text(e) { return e } link(e, t, n) { return "" + n } image(e, t, n) { return "" + n } br() { return "" } html(e) { return e } }, e.Parser = r, e.Lexer = c, e.Slugger = class { constructor() { this.seen = {} } slug(e) { let t = e.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-"); if (this.seen.hasOwnProperty(t)) { const e = t; do { this.seen[e]++, t = e + "-" + this.seen[e] } while (this.seen.hasOwnProperty(t)) } return this.seen[t] = 0, t } }, e.Hooks = class { constructor(e) { this.options = e || a.defaults } preprocess(e) { return e } postprocess(e) { return e } }, Object.defineProperty(e, "__esModule", { value: !0 })}));
